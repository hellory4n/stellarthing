#include <raylib.h>
#include <rlgl.h>
#include <raymath.h>
#include <libtrippin.h>
#include "graphics.h"

static TrArena arenadeez;

static RenderTexture2D render_target;

static TrSlice objs;
static size_t obj_len;
static Camera3D current_cam;
static bool wireframe_mode;
static Shader light_shader;

void graphics_init(void)
{
	arenadeez = tr_arena_new(TR_MB(1));

	// 2d crap
	render_target = LoadRenderTexture(ST_2D_RENDER_WIDTH, ST_2D_RENDER_HEIGHT);

	// 3d crap
	objs = tr_slice_new(arenadeez, ST_MAX_3D_OBJECTS, sizeof(Object3D));

	// man.
	light_shader = LoadShader("assets/shader/light.vert", "assets/shader/light.frag");
	Vector3 light_dir = { -0.5f, -1.0f, -0.5f };
	SetShaderValue(light_shader, GetShaderLocation(light_shader, "lightDir"), &light_dir, SHADER_UNIFORM_VEC3);

	Vector4 ambient = { 0.2f, 0.2f, 0.2f, 1.0f };
	SetShaderValue(light_shader, GetShaderLocation(light_shader, "ambient"), &ambient, SHADER_UNIFORM_VEC4);

	tr_log(TR_LOG_INFO, "initialized graphics");
}

void graphics_free(void)
{
	tr_arena_free(arenadeez);
	UnloadShader(light_shader);
	UnloadRenderTexture(render_target);

	tr_log(TR_LOG_INFO, "deinitialized graphics");
}

void graphics_begin_2d(void)
{
	BeginTextureMode(render_target);
	ClearBackground(BLANK);
}

void graphics_end_2d(void)
{
	EndTextureMode();

	double scale = fmin(
		GetRenderWidth() / (double)ST_2D_RENDER_WIDTH,
		GetRenderHeight() / (double)ST_2D_RENDER_HEIGHT
	);
	double x = (GetRenderWidth() - ST_2D_RENDER_WIDTH * scale) * 0.5;
	double y = (GetRenderHeight() - ST_2D_RENDER_HEIGHT * scale) * 0.5;
	double w = ST_2D_RENDER_WIDTH * scale;
	double h = ST_2D_RENDER_HEIGHT * scale;

	DrawTexturePro(
		render_target.texture,
		(Rectangle){0, 0, render_target.texture.width, -render_target.texture.height},
		(Rectangle){x, y, w, h},
		(Vector2){0, 0}, 0, WHITE
	);
}

void graphics_set_camera(Camera3D cam)
{
	current_cam = cam;
}

Camera3D graphics_camera(void)
{
	return current_cam;
}

void graphics_draw_3d_obj(Object3D obj)
{
	// don't mysteriously crash
	if (obj_len >= ST_MAX_3D_OBJECTS) {
		tr_log(TR_LOG_WARNING, "too many 3d objects", ST_MAX_3D_OBJECTS);
		return;
	}

	*(Object3D*)tr_slice_at(objs, obj_len) = obj;
	obj_len++;
}

// help me
void graphics_draw_all_3d_objects(void)
{
	if (IsKeyPressed(KEY_F5)) {
		wireframe_mode = !wireframe_mode;
	}

	BeginMode3D(current_cam);

	// why not
	DrawGrid(100, 1);

	if (wireframe_mode) {
		rlEnableWireMode();
	}
	else {
		BeginShaderMode(light_shader);
	}

	// we don't iterate over the max objs because what if i make that ridiculously big
	// it'll be wasting time on nothing
	for (size_t obj_idx = 0; obj_idx < obj_len; obj_idx++) {
		Object3D obj = *(Object3D*)tr_slice_at(objs, obj_idx);

		// raylib's DrawModelEx() has a weird rotation parameter
		// to get our full fancy rotation we have to make our own drawing
		// this is just raylib's DrawModelEx() with the rotation fixed
		// and also some shader stuff

		// Calculate transformation matrix from function parameters
		// Get transform matrix (rotation -> scale -> translation)
		Matrix mat_scale = MatrixScale(obj.scale.x / ST_VOXEL_SIZE, obj.scale.y / ST_VOXEL_SIZE, obj.scale.z / ST_VOXEL_SIZE);
		Matrix mat_rotation = MatrixRotateXYZ((Vector3){tr_deg2rad(obj.rotation.x), tr_deg2rad(obj.rotation.y), tr_deg2rad(obj.rotation.z)});
		Matrix mat_translation = MatrixTranslate(obj.position.x, obj.position.y, obj.position.z);

		Matrix mat_transform = MatrixMultiply(MatrixMultiply(mat_scale, mat_rotation), mat_translation);

		// Combine model transformation matrix (model.transform) with matrix generated by function parameters (matTransform)
		Model model = obj.model;
		model.transform = MatrixMultiply(MatrixIdentity(), mat_transform);

		for (int mesh_idx = 0; mesh_idx < model.meshCount; mesh_idx++) {
			Color color = model.materials[model.meshMaterial[mesh_idx]].maps[MATERIAL_MAP_DIFFUSE].color;

			Color color_tint = WHITE;
			color_tint.r = (uint8_t)(((int32_t)color.r * (int32_t)obj.tint.r) / 255);
			color_tint.g = (uint8_t)(((int32_t)color.g * (int32_t)obj.tint.g) / 255);
			color_tint.b = (uint8_t)(((int32_t)color.b * (int32_t)obj.tint.b) / 255);
			color_tint.a = (uint8_t)(((int32_t)color.a * (int32_t)obj.tint.a) / 255);

			if (!wireframe_mode) {
				model.materials[model.meshMaterial[mesh_idx]].shader = light_shader;
				Vector4 please = {color_tint.r / 256.0f, color_tint.g / 256.0f, color_tint.b / 256.0f, color_tint.a / 256.0f};
				SetShaderValue(light_shader, GetShaderLocation(light_shader, "materialColor"), &please, SHADER_UNIFORM_VEC4);
			}
			else {
				// use default shader
				model.materials[model.meshMaterial[mesh_idx]].shader = LoadShader(NULL, NULL);
			}
			model.materials[model.meshMaterial[mesh_idx]].maps[MATERIAL_MAP_DIFFUSE].color = color_tint;
			DrawMesh(model.meshes[mesh_idx], model.materials[model.meshMaterial[mesh_idx]], model.transform);
			model.materials[model.meshMaterial[mesh_idx]].maps[MATERIAL_MAP_DIFFUSE].color = color;
		}
	}

	if (wireframe_mode) {
		rlDisableWireMode();
	}
	else {
		EndShaderMode(); // light_shader
	}
	EndMode3D();

	// it'll just start overwriting things
	obj_len = 0;
}
